<!doctype html>
<html lang="en">
<head>
  
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Is it nice?</title>

  <!-- Favicon -->
  <link rel="icon" href="/favicon.ico">
  <!-- Optional: better modern support -->
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

  <!-- Social preview (Open Graph + Twitter) -->
  <meta property="og:title" content="Is it nice?">
  <meta property="og:description" content="Weather-powered decisions, delivered with maximum sass.">
  <meta property="og:url" content="https://isitnice.live/">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://isitnice.live/og.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Is it nice?">
  <meta name="twitter:description" content="Weather-powered decisions, delivered with maximum sass.">
  <meta name="twitter:image" content="https://isitnice.live/og.png">

  <style>
    :root{
      --radius: 22px;
      --radius2: 16px;
      --shadow: 0 12px 32px rgba(0,0,0,.10);

      --yes: #19c37d;
      --no: #ff4d4d;
      --maybe: #ffb020;

      --blue: rgba(78,134,255,.85);
      --mint: rgba(25,195,125,.85);
      --sun: rgba(255,176,32,.85);

      --bg: #f6f7fb;
      --text: #101114;
      --muted: rgba(16,17,20,.62);
      --card: rgba(255,255,255,.86);
      --card2: rgba(255,255,255,.75);
      --stroke: rgba(20,20,20,.10);
      --chip: rgba(16,17,20,.07);
      --chipText: rgba(16,17,20,.78);

      --accentGlow: rgba(78,134,255,.14);
      --okGlow: rgba(25,195,125,.18);

      --tabBg: rgba(255,255,255,.60);
    }

    body[data-theme="dark"]{
      --bg: #0b1020;
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --card: rgba(18,24,44,.66);
      --card2: rgba(18,24,44,.52);
      --stroke: rgba(255,255,255,.10);
      --chip: rgba(255,255,255,.08);
      --chipText: rgba(255,255,255,.78);
      --shadow: 0 18px 40px rgba(0,0,0,.35);
      --accentGlow: rgba(78,134,255,.22);
      --okGlow: rgba(25,195,125,.22);
      --tabBg: rgba(18,24,44,.42);
    }
    .unitBtn{
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.9);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 900;
      font-size: 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,.06);
      user-select: none;
      white-space: nowrap;
      width: 130px;
      text-align: center;
    }

    body[data-theme="dark"] .unitBtn{
      background: rgba(18,24,44,.88);
      box-shadow: 0 10px 24px rgba(0,0,0,.28);
    }
    .unitBtn:hover{ opacity: .95; }
    .unitBtn:active{ transform: translateY(1px); }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(25,195,125,.10), transparent 55%),
        radial-gradient(900px 500px at 85% 20%, rgba(255,176,32,.10), transparent 55%),
        radial-gradient(900px 700px at 50% 100%, rgba(78,134,255,.10), transparent 60%),
        var(--bg);
      min-height:100vh;
      padding:24px;
    }

    .wrap{ max-width: 1060px; margin: 0 auto; }

    header{
      display:flex; gap:16px; align-items:flex-start; justify-content:space-between;
      flex-wrap:wrap; margin-bottom:14px;
    }

    .brand{ display:flex; gap:12px; align-items:center; }
    .logo{
      width:44px;height:44px;border-radius:14px;
      background: linear-gradient(145deg, var(--mint), var(--blue));
      box-shadow: 0 10px 30px rgba(25,195,125,.18);
      position:relative; overflow:hidden;
    }
    .logo:before{
      content:""; position:absolute; inset:-30%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.55), transparent 50%);
      transform: rotate(25deg);
    }
    .brand h1{ margin:0; font-size: 18px; letter-spacing:.2px; }
    .brand p{ margin:2px 0 0; font-size: 13px; color: var(--muted); }

    .topRight{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
      flex:1;
      min-width: 360px;
      max-width: 680px;
      align-items:stretch;
    }

    .searchBarPanel{
      position: relative;
      z-index: 1000;
    }

    .searchPill{
      width: 100%;
      display: flex;
      align-items: center;
      gap: 14px;

      padding: 18px 22px;
      border-radius: 999px;

      background: rgba(18, 24, 44, .55);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 14px 34px rgba(0,0,0,.25);

      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);

      position: relative;
      z-index: 1001;
    }

    body[data-theme="light"] .searchPill{
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(20,20,20,.10);
      box-shadow: 0 14px 34px rgba(0,0,0,.10);
    }
    body[data-theme="light"] .suggestions{
      background-color: #ffffff;
      border-color: rgba(20,20,20,.15);
      box-shadow: 0 18px 40px rgba(0,0,0,.15);
    }
    body[data-theme="light"] .sItem + .sItem{
      border-top: 1px solid rgba(0,0,0,.08);
    }
    .searchIcon{ font-size: 22px; opacity: .9; }

    .searchPill input{
      flex: 1;
      border: 0;
      outline: 0;
      background: transparent;
      font-size: 22px;
      font-weight: 700;
      color: var(--text);
      min-width: 120px;
    }

    .searchPill input::placeholder{ color: rgba(255,255,255,.70); }
    body[data-theme="light"] .searchPill input::placeholder{ color: rgba(16,17,20,.55); }

    .pillBtn{
      border: 0;
      outline: 0;
      background: rgba(255,255,255,.10);
      color: var(--text);
      width: 42px;
      height: 42px;
      border-radius: 999px;
      cursor: pointer;
      display: grid;
      place-items: center;
      position: relative;
      flex: 0 0 auto;
    }
    body[data-theme="light"] .pillBtn{ background: rgba(16,17,20,.08); }
    .pillBtn:hover{ opacity: .92; }
    .pillBtn:disabled{ opacity: .55; cursor: not-allowed; }

    .pillBtn.loading::after{
      content:"";
      position:absolute;
      inset: 7px;
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,.25);
      border-top-color: rgba(255,255,255,.85);
      animation: spin 0.85s linear infinite;
      pointer-events: none;
    }
    body[data-theme="light"] .pillBtn.loading::after{
      border-color: rgba(16,17,20,.18);
      border-top-color: rgba(16,17,20,.72);
    }
    @keyframes spin{ to{ transform: rotate(360deg); } }

    .suggestions{
      position: absolute;
      left: 14px;
      right: 14px;
      top: calc(100% + 10px);
      z-index: 9999;

      /* FORCE SOLID COLOUR */
      background-color: #0e1428; /* dark mode base */
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 18px;

      box-shadow: 0 20px 50px rgba(0,0,0,.55);

      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;

      overflow: hidden;
      display: none;
    }


    .suggestions.show{
      display: block;
    }

    .sItem{
      padding: 14px 16px;
      cursor: pointer;
      display: flex;
      gap: 12px;
      align-items: flex-start;

      background: transparent;
    }
    .sItem + .sItem{
      border-top: 1px solid rgba(255,255,255,.08);
    }

    .sItem:hover,
    .sItem.active{
      background: rgba(78,134,255,.18);
    }

    .sItem .sTitle{
      font-weight: 900;
      font-size: 14px;
      line-height: 1.2;
    }
    .sItem .sSub{
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
      line-height: 1.2;
    }
    .sPin{ opacity:.9; padding-top: 1px; }

    .searchHint{
      margin-top: 8px;
      padding-left: 14px;
      font-size: 12px;
      color: var(--muted);
    }

    .btn{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.9);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor:pointer;
      transition: transform .06s ease, background .2s ease, opacity .2s ease;
      box-shadow: 0 10px 24px rgba(0,0,0,.06);
      user-select:none;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }
    body[data-theme="dark"] .btn{
      background: rgba(18,24,44,.88);
      box-shadow: 0 10px 24px rgba(0,0,0,.28);
    }
    .btn:hover{ opacity:.95 }
    .btn:active{ transform: translateY(1px) }
    .btn.on{
      border-color: rgba(78,134,255,.45);
      box-shadow: 0 14px 30px var(--accentGlow);
    }
    .btn.primary{
      border-color: rgba(25,195,125,.35);
      box-shadow: 0 14px 30px var(--okGlow);
    }
    .btn.coffee{
      background: #ffdd00;
      color:#000;
      font-weight:900;
      border-color: rgba(0,0,0,.10);
    }
    body[data-theme="dark"] .btn.coffee{
      background: #ffdd00;
      color:#000;
      border-color: rgba(0,0,0,.12);
    }

    .toggles{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-start;
      flex: 0 0 auto;
      flex-wrap:wrap;
    }
    .toggles .coffee{ margin-left: auto; }

    .tabs{
      width:100%;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-start;
    }

    .controlsRow{
      width:100%;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:flex-start;
      flex-wrap:wrap;
    }

    .tab{
      border:0;
      background: transparent;
      color: var(--muted);
      font-weight: 900;
      padding: 10px 12px;
      border-radius: 999px;
      cursor:pointer;
      display:flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    .tab.active{
      background: var(--card);
      border: 1px solid var(--stroke);
      color: var(--text);
      box-shadow: 0 10px 24px rgba(0,0,0,.06);
    }

    main{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap:16px;
    }
    @media (max-width: 900px){ main{ grid-template-columns: 1fr; } }

    .panel{
      background: var(--card);
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      padding:18px;
    }

    .hero{ display:flex; gap:16px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap; }
    .bigAnswer{ display:flex; gap:14px; align-items:center; flex-wrap:wrap; }

    .badge{
      font-size: 56px; font-weight: 900; letter-spacing: -2px; line-height: 1; margin:0;
    }
    .badge.yes{ color: var(--yes) }
    .badge.no{ color: var(--no) }
    .badge.maybe{ color: var(--maybe) }

    .question{ font-weight: 800; font-size: 16px; margin:0 0 4px; }
    .quip{ margin:0; color: var(--muted); font-size: 14px; max-width: 560px; }
    .reason{
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 13px;
      max-width: 560px;
      min-height: 1.35em;
      line-height: 1.35em;
    }

    .metaRow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap: nowrap;
      margin-top: 4px;
    }
    @media (max-width: 520px){
      .metaRow{ flex-wrap: wrap; justify-content:flex-start; }
    }

    .chip{
      padding:8px 10px; border-radius: 999px;
      background: var(--chip);
      color: var(--chipText);
      font-size: 12px;
      border:1px solid rgba(255,255,255,.0);

      max-width: 360px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    body[data-theme="dark"] .chip{ border-color: rgba(255,255,255,.06); }

    .forecastTitle{
      margin: 16px 0 10px;
      color: var(--muted);
      font-size: 12px;
      font-weight: 800;
      letter-spacing: .12em;
      text-transform: uppercase;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }

    .days{
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      gap:10px;
    }
    @media (max-width: 900px){ .days{ grid-template-columns: repeat(4, 1fr); } }
    @media (max-width: 540px){ .days{ grid-template-columns: repeat(3, 1fr); } }

    .dayCard{
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 16px;
      padding:10px;
      cursor:pointer;
      transition: transform .08s ease, border-color .2s ease, background .2s ease;
      user-select:none;
    }
    .dayCard:hover{ transform: translateY(-1px); background: rgba(255,255,255,.92); }
    body[data-theme="dark"] .dayCard:hover{ background: rgba(18,24,44,.72); }

    .dayCard.active{
      border-color: rgba(78,134,255,.45);
      box-shadow: 0 12px 26px var(--accentGlow);
      background: rgba(255,255,255,.95);
    }
    body[data-theme="dark"] .dayCard.active{ background: rgba(18,24,44,.78); }

    .dayTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom:8px;
    }
    .dow{ font-weight: 900; font-size: 12px; }
    .emoji{ font-size: 18px; }

    .mini{
      display:flex; align-items:center; justify-content:space-between;
      gap:8px; color: var(--muted); font-size: 12px;
    }
    .mini strong{ color: var(--text) }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:12px;
    }
    .metric{
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 18px;
      padding:12px 12px;
    }
    .metric .label{
      font-size: 12px; color: var(--muted);
      font-weight: 800; letter-spacing:.06em;
      text-transform: uppercase;
      display:flex; gap:8px; align-items:center;
    }
    .metric .value{
      margin-top:6px;
      font-size: 18px;
      font-weight: 900;
      letter-spacing:-.2px;
      line-height: 1.25;
    }
    .wide{ grid-column: 1 / -1; }

    .smallNote{
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 16px;
      background: rgba(25,195,125,.12);
      border:1px solid rgba(25,195,125,.20);
      color: rgba(10,50,35,.90);
      font-weight: 700;
      font-size: 13px;
    }
    body[data-theme="dark"] .smallNote{
      color: rgba(215,255,238,.90);
      background: rgba(25,195,125,.16);
      border-color: rgba(25,195,125,.22);
    }

    .asideTitle{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; margin-bottom: 10px;
    }
    .asideTitle h2{ margin:0; font-size: 14px; letter-spacing:.2px; }
    .asideTitle span{ font-size: 12px; color: var(--muted); font-weight: 800; }

    .list{ display:flex; flex-direction:column; gap:10px; }
    .tip{
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 18px;
      padding: 12px;
    }
    .tip b{ display:block; margin-bottom: 6px; }
    .tip p{ margin:0; color: var(--muted); font-size: 13px; line-height: 1.4; }

    .tip .small{
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .footerBar{
      margin-top: 18px;
      color: var(--muted);
      font-size: 12px;
      text-align:center;
    }

    .hidden{ display:none !important; }

    .aboutWrap{ display:grid; grid-template-columns: 1fr; gap:16px; }
    .aboutTitle{ font-size: 34px; margin: 0 0 8px; letter-spacing: -1px; font-weight: 950; }
    .aboutText{ margin:0; color: var(--muted); font-size: 16px; line-height: 1.55; max-width: 820px; }
    .aboutSectionTitle{
      margin: 18px 0 8px;
      font-weight: 950;
      letter-spacing: .08em;
      color: var(--text);
      text-transform: uppercase;
      font-size: 12px;
    }
    .scienceList{ margin: 0; padding-left: 18px; color: var(--text); }
    .scienceList li{ margin: 10px 0; line-height: 1.5; }
    .scienceList li span{ color: var(--muted); font-weight: 600; }
    .twoCards{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top: 10px; }
    @media (max-width: 760px){ .twoCards{ grid-template-columns: 1fr; } }
    .ctaRow{ display:flex; gap:12px; flex-wrap:wrap; margin-top: 14px; }
    a.link{ color: inherit; }

    /* ---------- Weather preferences ---------- */
.prefRow{
  display:flex;
  flex-direction:column;
  gap:10px;
  margin-top: 8px;
}

.prefLine{
  display:grid;
  grid-template-columns: 1fr auto;
  gap:10px;
  align-items:center;
}

.prefLabel{
  font-weight: 900;
  font-size: 12px;
  color: var(--muted);
  letter-spacing:.06em;
  text-transform: uppercase;
}

.prefValue{
  font-weight: 900;
  font-size: 12px;
  color: var(--text);
  background: var(--chip);
  border: 1px solid rgba(255,255,255,.06);
  padding: 6px 10px;
  border-radius: 999px;
  white-space: nowrap;
}

/* ---------- Single range sliders (Rain/Wind) styled like temp ---------- */
.prefSlider{
  width: 100%;
  height: 34px;
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  --pct: 0%;
}

/* Track (filled left -> grey right) */
.prefSlider::-webkit-slider-runnable-track{
  height: 8px;
  border-radius: 999px;
  background:
    linear-gradient(to right,
      rgba(78,134,255,.95) 0 var(--pct),
      rgba(255,255,255,.14) var(--pct) 100%);
  border: 1px solid rgba(255,255,255,.10);
}
body[data-theme="light"] .prefSlider::-webkit-slider-runnable-track{
  background:
    linear-gradient(to right,
      rgba(78,134,255,.95) 0 var(--pct),
      rgba(16,17,20,.10) var(--pct) 100%);
  border-color: rgba(16,17,20,.10);
}

/* Thumb */
.prefSlider::-webkit-slider-thumb{
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 999px;
   background: #ffffff;
  background: rgba(255,255,255,.92);
  border: 2px solid rgba(78,134,255,.95);
  margin-top: -5px;
  box-shadow: 0 10px 22px rgba(0,0,0,.25);
}

/* Firefox */
.prefSlider::-moz-range-track{
  height: 8px;
  border-radius: 999px;
  background: rgba(255,255,255,.14);
  border: 1px solid rgba(255,255,255,.10);
}
body[data-theme="light"] .prefSlider::-moz-range-track{
  background: rgba(16,17,20,.10);
  border-color: rgba(16,17,20,.10);
}
.prefSlider::-moz-range-progress{
  height: 8px;
  border-radius: 999px;
  background: rgba(78,134,255,.95);
}
.prefSlider::-moz-range-thumb{
  width: 18px;
  height: 18px;
  border-radius: 999px;
  background: rgba(255,255,255,.92);
  border: 2px solid rgba(78,134,255,.95);
  box-shadow: 0 10px 22px rgba(0,0,0,.25);
}


/* --- Dual range: only fill between min & max --- */
.dualRange{
  position: relative;
  width: 100%;
  height: 34px;
  margin-top: 6px;
  display: grid;
  align-items: center;
}

.rangeRail{
  position: absolute;
  left: 0;
  right: 0;
  height: 8px;
  border-radius: 999px;
  background: rgba(255,255,255,.14);
  border: 1px solid rgba(255,255,255,.10);
}

body[data-theme="light"] .rangeRail{
  background: rgba(16,17,20,.10);
  border-color: rgba(16,17,20,.10);
}

.rangeFill{
  position: absolute;
  height: 8px;
  border-radius: 999px;
  background: rgba(78,134,255,.95);
  left: 0%;
  width: 0%;
  pointer-events: none;
  box-shadow: 0 10px 24px rgba(78,134,255,.20);
}

/* Put sliders on top */
.rangeInput{
  position: absolute;
  left: 0;
  right: 0;
  width: 100%;
  margin: 0;
  height: 34px;
  background: transparent;
  -webkit-appearance: none;
  appearance: none;
  z-index: 2;
  pointer-events: none;
}

/* Make tracks transparent so the browser fill disappears */
.rangeInput::-webkit-slider-runnable-track{
  height: 8px;
  background: transparent;
}
.rangeInput::-moz-range-track{
  height: 8px;
  background: transparent;
}

/* Thumbs */
.rangeInput::-webkit-slider-thumb{
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 999px;
  background: rgba(255,255,255,.92);
  border: 2px solid rgba(78,134,255,.95);
  margin-top: -5px;
  box-shadow: 0 10px 22px rgba(0,0,0,.25);
}
.rangeInput::-moz-range-thumb{
  width: 18px;
  height: 18px;
  border-radius: 999px;
  background: rgba(255,255,255,.92);
  border: 2px solid rgba(78,134,255,.95);
  box-shadow: 0 10px 22px rgba(0,0,0,.25);
}



  </style>
</head>



<body data-theme="dark">
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Is it nice?</h1>
          <p>Weather-powered decisions, delivered with maximum sass.</p>
        </div>
      </div>

      <div class="topRight">
        <div class="tabs" role="tablist" aria-label="Pages">
          <button class="tab active" id="tabDashboard" role="tab" aria-selected="true">ğŸŒ¤ï¸ Dashboard</button>
          <button class="tab" id="tabAbout" role="tab" aria-selected="false">â„¹ï¸ About</button>
        </div>

        <div class="controlsRow">
          <div class="toggles" id="toggleRow">
            <button class="btn" id="sassBtn" title="Make the app extra unhinged">âœ¨ Extra Sass: Off</button>
            <button class="btn" id="themeBtn" title="Theme: Auto â†’ Light â†’ Dark">ğŸ¨ Theme: Auto</button>
            <a class="btn coffee" href="https://buymeacoffee.com/teraau" target="_blank" rel="noopener">â˜• Buy me a coffee</a>
          </div>
        </div>
      </div>
    </header>

    <!-- DASHBOARD -->
    <section id="pageDashboard">
      <div class="searchBarPanel" id="searchRow">
        <div class="searchPill" title="Search a location">
          <span class="searchIcon" aria-hidden="true">ğŸ”</span>

          <input
            id="placeInput"
            placeholder="Search suburb/city (e.g., Melbourne, Victoria)"
            autocomplete="off"
          />

          <button class="pillBtn" id="useMeBtn" type="button" title="Use my location" aria-label="Use my location">ğŸ“</button>

          <div class="suggestions" id="suggestions" role="listbox" aria-label="Location suggestions"></div>
        </div>

        <div class="searchHint">Type to see suggestions, or press Enter</div>
      </div>

      <main>
        <section class="panel" id="mainPanel">
          <div class="hero">
            <div class="bigAnswer">
              <h2 class="badge maybe" id="answerText">MAYBE</h2>
              <div>
                <p class="question">Is it nice?</p>
                <p class="quip" id="quipText">Loading the skyâ€™s mood...</p>
                <p class="reason" id="reasonText"></p>
              </div>
            </div>

            <div class="metaRow">
              <button class="unitBtn" id="unitBtn" type="button" title="Toggle Â°C / Â°F">ğŸŒ¡ï¸ Â°C</button>
              <div class="chip" id="timeChip">â±ï¸ â€”</div>
              <div class="chip" id="locationChip">ğŸ“ Finding youâ€¦</div>
            </div>


          <div class="forecastTitle">
            <div>7-day outlook (click a day)</div>
            <div class="chip" id="selectedChip">Selected: Today</div>
          </div>

          <div class="days" id="daysRow"></div>
          <div class="metric wide" id="currentMetric" style="display:none; margin-top:12px;">
            <div class="label">ğŸ•’ Current conditions</div>
            <div class="value" id="currentVal">â€”</div>
          </div>

          <div class="grid2">
            <div class="metric">
              <div class="label">ğŸ’§ Humidity</div>
              <div class="value" id="humidityVal">â€”</div>
            </div>
            <div class="metric">
              <div class="label">ğŸ’¨ Wind</div>
              <div class="value" id="windVal">â€”</div>
            </div>

            <div class="metric">
              <div class="label">â˜” Rain chance</div>
              <div class="value" id="rainVal">â€”</div>
            </div>
            <div class="metric">
              <div class="label">ğŸŒ¡ï¸ Temp</div>
              <div class="value" id="tempVal">â€”</div>
            </div>

            <div class="metric wide">
              <div class="label">ğŸ•¶ï¸ UV status</div>
              <div class="value" id="uvVal">â€”</div>
            </div>

            <div class="metric wide">
              <div class="label">â° Best time to go outside</div>
              <div class="value" id="bestTimeVal">â€”</div>
            </div>

            <div class="smallNote wide" id="moneyNote">
              ğŸŒ¿ Choosing outside might save ~$1.50 and 2kg COâ‚‚ (scientific vibes, not science).
            </div>
          </div>
        </section>

        <aside class="panel">
          <div class="asideTitle">
            <h2>Outside survival guide</h2>
            <span id="extraSummary">â€”</span>
          </div>

          <div class="list">
            
            
            <div class="tip" id="prefsCard">
              <b>âš™ï¸ Weather preferences</b>
              <p class="small">Adjust the sliders to your preferences</p>

              <div class="prefRow">
                
              <!-- Temperature (min + max) -->
                <div class="prefLine">
                  <div class="prefLabel">Ideal temperature range</div>
                  <div class="prefValue" id="tempPrefVal">â€”</div>
                </div>

                <div class="dualRange" id="tempDualRange">
                  <div class="rangeRail"></div>
                  <div class="rangeFill" id="tempRangeFill"></div>

                  <input class="prefSlider rangeInput" id="tempMinPref" type="range" min="-5" max="40" step="1" value="18" />
                  <input class="prefSlider rangeInput" id="tempMaxPref" type="range" min="-5" max="40" step="1" value="26" />
                </div>


                <!-- Rain -->
                <div class="prefLine">
                  <div class="prefLabel">Max Rain</div>
                  <div class="prefValue" id="rainPrefVal">â€”</div>
                </div>
                <input class="prefSlider" id="rainPref" type="range" min="0" max="100" step="1" value="25" />

                <!-- Wind -->
                <div class="prefLine">
                  <div class="prefLabel">Max Wind</div>
                  <div class="prefValue" id="windPrefVal">â€”</div>
                </div>
                <input class="prefSlider" id="windPref" type="range" min="0" max="60" step="1" value="25" />
              </div>
            </div>

            <div class="tip">
              <b>ğŸ§¢ What to wear (Male)</b>
              <p id="maleOutfitText">â€”</p>
            </div>

            <div class="tip">
              <b>ğŸ‘— What to wear (Female)</b>
              <p id="femaleOutfitText">â€”</p>
            </div>


            <div class="tip">
              <b>ğŸƒ Ideas (Outside)</b>
              <div id="outsideIdeasText" class="small">â€”</div>
            </div>

            <div class="tip">
              <b>ğŸ›‹ï¸ Ideas (Inside)</b>
              <div id="insideIdeasText" class="small">â€”</div>
            </div>

            <div class="tip">
              <b>ğŸ’¬ Sassy motivation</b>
              <p id="motivationText">â€”</p>
            </div>

            <div class="tip">
              <b>ğŸ“¡ Data source</b>
              <p>Weather data by Open-Meteo (forecast + geocoding). No API key needed.</p>
              <p class="small">Disclaimer: for fun, not safety-critical planning. Check official sources for severe weather.</p>
            </div>
          </div>
        </aside>
      </main>

      <div class="footerBar">
        Â© <span id="yearNow"></span> â€” Luke Baldacchino - Tera Apps. Weather data by Open-Meteo.
      </div>
    </section>

    <!-- ABOUT -->
    <section id="pageAbout" class="hidden">
      <div class="panel aboutWrap">
        <h2 class="aboutTitle">Why â€œIs it nice?â€</h2>
        <p class="aboutText">
          I made this because â€œis it a good day to go out?â€ is a daily question â€” and the weather apps often give
          you <i>data</i>, not a <i>decision</i>. This site tries to translate forecast chaos into a simple YES/NO/MAYBE,
          plus some practical tips and a little sass to keep it interesting.
        </p>

        <div class="aboutSectionTitle">How it decides</div>
        <p class="aboutText">
          The decision weighs rain probability, wind, temperature comfort, and UV (daytime only). Then it picks the best
          â€œgo outsideâ€ window by scanning hourly conditions and choosing the strongest 2-hour period (9amâ€“5pm).
        </p>

        <div class="aboutSectionTitle">The â€œscience-ishâ€ bits</div>
        <ol class="scienceList">
          <li><b>Moisture & rain risk</b>: <span>If precipitation probability is high, your plans may become â€œindoor plans.â€</span></li>
          <li><b>Wind</b>: <span>Strong wind makes â€œpleasantâ€ feel like â€œaggressively unpleasant.â€ Also: hats die.</span></li>
          <li><b>UV</b>: <span>High UV can turn a nice day into a â€œwear sunscreen or perishâ€ situation.</span></li>
          <li><b>Comfort</b>: <span>Extreme temps lower the score, because sweating or freezing is not leisure.</span></li>
        </ol>

        <div class="twoCards">
          <div class="tip">
            <b>ğŸ“¡ Data source</b>
            <p>
              Weather data is provided by Open-Meteo (forecast + geocoding).
              This website is not affiliated with Open-Meteo.
            </p>
          </div>
          <div class="tip">
            <b>ğŸ”’ Privacy</b>
            <p>
              Your location is used only to fetch weather in your browser. This site does not run invasive ads and does not sell data.
              If you use â€œUse my locationâ€, your browser may request permission.
            </p>
          </div>
        </div>

        <div class="aboutSectionTitle">Support & contact</div>
        <p class="aboutText">
          If you found this useful/funny, you can fuel future updates (and future sass).
        </p>
        <div class="ctaRow">
          <a class="btn coffee" href="https://buymeacoffee.com/teraau" target="_blank" rel="noopener">â˜• Support the maker</a>
          <a class="btn primary" href="https://www.linkedin.com/in/lukebaldacchino/" target="_blank" rel="noopener">ğŸ’¬ Talk to me</a>
         
        </div>

        <div class="aboutSectionTitle">Legal-ish disclaimer</div>
        <p class="aboutText">
          This tool is for entertainment and general guidance only. Forecasts can be wrong. Donâ€™t rely on this for safety-critical decisions.
          Always check local warnings for severe weather and emergencies.
        </p>
      </div>

      <div class="footerBar">
        Â© <span id="yearNow"></span> â€” Luke Baldacchino - Tera Apps. Weather data by Open-Meteo.
      </div>
    </section>
  </div>

<script>
(() => {
  const GEO_URL = "https://geocoding-api.open-meteo.com/v1/search";
  const GEO_REV_URL = "https://geocoding-api.open-meteo.com/v1/reverse";
  const FORECAST_URL = "https://api.open-meteo.com/v1/forecast";
  const BDC_REV_URL = "https://api.bigdatacloud.net/data/reverse-geocode-client";


  const tabDashboard = document.getElementById("tabDashboard");
  const tabAbout = document.getElementById("tabAbout");
  const pageDashboard = document.getElementById("pageDashboard");
  const pageAbout = document.getElementById("pageAbout");
  const unitBtn = document.getElementById("unitBtn");

  

  const placeInput = document.getElementById("placeInput");
  const useMeBtn = document.getElementById("useMeBtn");
  const sassBtn = document.getElementById("sassBtn");
  const themeBtn = document.getElementById("themeBtn");

  const suggestionsEl = document.getElementById("suggestions");

  const answerText = document.getElementById("answerText");
  const quipText = document.getElementById("quipText");
  const reasonText = document.getElementById("reasonText");
  const locationChip = document.getElementById("locationChip");
  const timeChip = document.getElementById("timeChip");
  const selectedChip = document.getElementById("selectedChip");
  const daysRow = document.getElementById("daysRow");

  const humidityVal = document.getElementById("humidityVal");
  const windVal = document.getElementById("windVal");
  const rainVal = document.getElementById("rainVal");
  const tempVal = document.getElementById("tempVal");
  const uvVal = document.getElementById("uvVal");
  const bestTimeVal = document.getElementById("bestTimeVal");
  const moneyNote = document.getElementById("moneyNote");

  const extraSummary = document.getElementById("extraSummary");
  const maleOutfitText = document.getElementById("maleOutfitText");
  const femaleOutfitText = document.getElementById("femaleOutfitText");
  const outsideIdeasText = document.getElementById("outsideIdeasText");
  const insideIdeasText = document.getElementById("insideIdeasText");
  const motivationText = document.getElementById("motivationText");
  const currentMetric = document.getElementById("currentMetric");
  const currentVal = document.getElementById("currentVal");

  
  const rainPref = document.getElementById("rainPref");
  const windPref = document.getElementById("windPref");
  // Temperature range sliders (min + max)
  const tempMinPref = document.getElementById("tempMinPref");
  const tempMaxPref = document.getElementById("tempMaxPref");
  const tempRangeFill = document.getElementById("tempRangeFill");
  const tempDualRange = document.getElementById("tempDualRange");



  const tempPrefVal = document.getElementById("tempPrefVal");
  const rainPrefVal = document.getElementById("rainPrefVal");
  const windPrefVal = document.getElementById("windPrefVal");

  



  document.getElementById("yearNow").textContent = new Date().getFullYear();

  let state = {
    name: "â€”",
    country: "",
    lat: null,
    lon: null,
    timezone: "auto",
    forecast: null,
    current: null, // { temp, wind, rain, humidity, uv }
    selectedIndex: 0,
    extraSass: false,
    themeMode: "dark",
    isNight: false,
    tempUnit: "C", // "C" or "F"
    prefs: {
      tempMin: 18,
      tempMax: 30,
      rainTolerance: 25,
      windTolerance: 30,
    },




    // suggestions
    suggestionItems: [],
    suggestionActiveIndex: -1,
    suggestionOpen: false,

    // maps
    quipsByDate: new Map(),
    bestWindowByDate: new Map(),
  };

  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  function cToF(c){ return (c * 9/5) + 32; }

  function kmhToMph(kmh){ return kmh * 0.621371; }

  function fmtWind(kmh){
    if (kmh == null) return "â€”";
    const v = (state.tempUnit === "F") ? kmhToMph(kmh) : kmh;
    const unit = (state.tempUnit === "F") ? "mph" : "km/h";
    return `${Math.round(v)} ${unit}`;
  }


  function fmtTemp(c){
    if (c == null) return "â€”";
    const v = (state.tempUnit === "F") ? cToF(c) : c;
    return `${Math.round(v)}Â°${state.tempUnit}`;
  }

  function setUnitButtonLabel(){
    if (!unitBtn) return;
    unitBtn.textContent =
      state.tempUnit === "F"
        ? "ğŸŒ¡ï¸ Â°F â€¢ ğŸ’¨ mph"
        : "ğŸŒ¡ï¸ Â°C â€¢ ğŸ’¨ km/h";
  }



  function escapeHtml(str){
    return String(str ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function dailySeed(dateStr){
    let h = 0;
    for (let i = 0; i < dateStr.length; i++){
      h = (h << 5) - h + dateStr.charCodeAt(i);
      h |= 0;
    }
    return Math.abs(h);
  }
  function pickByDay(arr, dateStr){
    const seed = dailySeed(dateStr);
    return arr[seed % arr.length];
  }
  function fmtDay(dateStr, tz){
    const d = new Date(dateStr + "T00:00:00");
    return d.toLocaleDateString(undefined, { weekday: "short", timeZone: tz || undefined });
  }
  function fmtShort(dateStr, tz){
    const d = new Date(dateStr + "T00:00:00");
    return d.toLocaleDateString(undefined, { month: "short", day: "numeric", timeZone: tz || undefined });
  }
  function uvLabel(uv){
    if (uv == null) return "â€”";
    if (uv >= 11) return "EXTREME";
    if (uv >= 8) return "VERY HIGH";
    if (uv >= 6) return "HIGH";
    if (uv >= 3) return "MODERATE";
    return "LOW";
  }

  function computeNightFlag(){
    const h = new Date().getHours();
    state.isNight = (h < 6 || h >= 19);
  }

  function dominantWeatherEmoji(day){
    const rain = day.precipProb ?? 0;
    const wind = day.windMax ?? 0;
    const uv = day.uvMax ?? 0;
    const tmax = day.tmax ?? 20;
    const tmin = day.tmin ?? 10;

    if (rain >= 70) return "ğŸŒ§ï¸";
    if (rain >= 35) return "ğŸŒ¦ï¸";
    if (wind >= 40) return "ğŸŒ¬ï¸";
    if (tmax >= 35) return "ğŸ”¥";
    if (tmin <= 1) return "ğŸ¥¶";
    if (uv >= 9) return "ğŸ« ";
    return "â˜€ï¸";
  }

  function scenarioKey(day){
    const rain = day.precipProb ?? 0;
    const wind = day.windMax ?? 0;
    const uv = day.uvMax ?? 0;
    const tmax = day.tmax ?? 20;
    const tmin = day.tmin ?? 10;

    if (rain >= 65) return "rain";
    if (wind >= 38) return "wind";
    if (tmax >= 35) return "hot";
    if (tmax <= 12 || tmin <= 2) return "cold";
    if (uv >= 9) return "uv";
    if (rain <= 15 && wind <= 20 && tmax >= 18 && tmax <= 30) return "perfect";
    return "meh";
  }

  const QUIPS = {
    normal: {
      rain: [
        "Rain is doing a surprise performance. Tickets are wet.",
        "Outside is currently in â€˜shower modeâ€™.",
        "Umbrella time. Or embrace your new life as a damp legend.",
        "Itâ€™s raining. Your socks are already filing complaints.",
        "If you go out, youâ€™ll return as a human sponge.",
        "Skyâ€™s crying. You donâ€™t have to."
      ],
      wind: [
        "Itâ€™s windy. Your hair will file a formal complaint.",
        "Great day to practise walking at a 45Â° angle.",
        "Windâ€™s up. Nature chose chaos.",
        "Hold your hat AND your dignity.",
        "If you hear a bin roll past, thatâ€™s just wind theatre.",
        "Outside is basically an air blender."
      ],
      uv: [
        "UV is spicy. Wear sunscreen unless you enjoy being a tomato.",
        "The sun is in full â€˜laser modeâ€™.",
        "SPF is your best friend today.",
        "UV is high. Put on sunscreen like itâ€™s armour.",
        "The sun is disrespectful today. Respond with SPF.",
        "Sunglasses recommended: yes."
      ],
      hot: [
        "Itâ€™s hot. Outside is basically a preheated oven.",
        "Hydrate, or become a crispy memory.",
        "If you go out, bring water and emotional support.",
        "Itâ€™s giving â€˜air fryerâ€™. You are the snack.",
        "Sunâ€™s cooking today. Donâ€™t volunteer as tribute.",
        "Heat mode: activated."
      ],
      cold: [
        "Itâ€™s cold. Outside is a freezer with opinions.",
        "Wear layers. All of them.",
        "Go out if you like your nose feeling betrayed.",
        "Cold today. Your hands will regret being hands.",
        "Outside is a fridge and youâ€™re the leftovers.",
        "Hot drink energy day."
      ],
      perfect: [
        "Elite outside conditions. Touch grass responsibly.",
        "Go out. Your future self will post about it.",
        "Itâ€™s a rare â€˜yesâ€™ from the sky. Donâ€™t waste it.",
        "Outside is actuallyâ€¦ nice? Suspicious.",
        "Todayâ€™s weather is carrying you.",
        "Fresh air DLC unlocked."
      ],
      meh: [
        "Proceed with mild confidence.",
        "Outside is fine. Not amazing. Like a microwave burrito.",
        "Itâ€™s a â€˜maybeâ€™ day. Choose chaos.",
        "Weatherâ€™s being indecisive. Same.",
        "You can go out, but keep expectations humble.",
        "Itâ€™s not badâ€¦ itâ€™s just not committed."
      ]
    },
    extra: {
      rain: [
        "Go outside if you want a free rinse cycle and a questionable mood.",
        "Rainy. Youâ€™ll return as a human sponge with regrets.",
        "Outside is wet. Your socks are already screaming.",
        "If you go out, youâ€™re basically consenting to soup weather.",
        "This is â€˜shower but publicâ€™ energy.",
        "Umbrella duel with the sky. You lose either way."
      ],
      wind: [
        "Wind level: â€˜your bin gets promoted to street artâ€™.",
        "If you go out, hold onto your hat and your self-esteem.",
        "Outside is running a leaf-based assault course.",
        "Wind is in its villain arc. Do not engage.",
        "Your hairstyle has a 0% survival rate today.",
        "Itâ€™s giving â€˜flying debrisâ€™ â€” but make it fashion."
      ],
      uv: [
        "UV is trying to cook you like a sausage at Bunnings.",
        "SPF or perish. Choose wisely.",
        "The sun is disrespectful today. Respond with sunscreen.",
        "UV is on hard mode. You are not.",
        "Todayâ€™s forecast: bright, bold, and personally insulting.",
        "Wear sunscreen like youâ€™re sponsored."
      ],
      hot: [
        "Itâ€™s hot enough to make your phone overheat emotionally.",
        "Outside is an air fryer. You are the snack.",
        "Heat is up. Donâ€™t become a cautionary tale.",
        "If you step outside, youâ€™ll instantly become â€˜medium rareâ€™.",
        "Hydrate like itâ€™s your job.",
        "Sunâ€™s angry. Donâ€™t argue back."
      ],
      cold: [
        "Cold. Your bones will make dial-up noises.",
        "Outside is a fridge and youâ€™re the leftovers.",
        "If you go out, the wind will personally insult you.",
        "You will not feel your face. Thatâ€™s the feature.",
        "Itâ€™s cold enough to humble your confidence.",
        "Layer up or suffer."
      ],
      perfect: [
        "Itâ€™s gorgeous. Go outside and pretend youâ€™re better than everyone.",
        "Touch grass. Reconnect with your firmware update (nature).",
        "Outside is flirting. Say yes.",
        "Sunshineâ€™s being nice â€” suspicious but acceptable.",
        "Go out and act like life is a montage.",
        "This is prime â€˜strutâ€™ weather."
      ],
      meh: [
        "Itâ€™s giving â€˜fineâ€™. Like a first-date that ends in â€˜weâ€™ll seeâ€™.",
        "You can go outâ€¦ but bring your expectations down to earth.",
        "Neutral weather. Maximum opportunity to overthink.",
        "Weatherâ€™s mid. Your attitude doesnâ€™t have to be.",
        "Itâ€™s not great, not terrible â€” just emotionally unavailable.",
        "Proceed with cautious optimism and snacks."
      ]
    }
  };

  function buildUniqueQuipsForWeek(dailyArr){
    const used = new Map();
    const out = new Map();

    function pickUnique(key, date){
      if (!used.has(key)) used.set(key, new Set());
      const usedSet = used.get(key);

      const pool = (state.extraSass ? QUIPS.extra[key] : QUIPS.normal[key]) || [];
      if (!pool.length) return "Weather is happening. React accordingly.";

      const seed = dailySeed(date + "|" + key);
      const step = 3;
      for (let attempt = 0; attempt < pool.length; attempt++){
        const idx = (seed + attempt * step) % pool.length;
        const candidate = pool[idx];
        if (!usedSet.has(candidate)){
          usedSet.add(candidate);
          return candidate;
        }
      }
      return pool[seed % pool.length];
    }

    for (const d of dailyArr){
      const key = scenarioKey(d);
      out.set(d.date, pickUnique(key, d.date));
    }
    return out;
  }

  function tempBandFromPrefs(){
    const comfortMin = clamp(state.prefs.tempMin, -5, 40);
    const comfortMax = clamp(state.prefs.tempMax, -5, 40);
    const coldMin = comfortMin - 8;
    return { comfortMin, comfortMax, coldMin };
  }


  function computeThresholds(){
    // Rain:
    // - rainTolerance is the max precip% for "YES"
    // - MAYBE band extends +20%
    const rainYesMax = clamp(state.prefs.rainTolerance, 0, 100);
    const rainMehMax = clamp(rainYesMax + 20, 0, 100);
    const rainBadMin = rainMehMax; // "bad" at/above meh max

    // Wind:
    // - windTolerance is the max wind for "YES"
    // - MAYBE band extends +12 km/h
    const windYesMax = clamp(state.prefs.windTolerance, 0, 60);
    const windMehMax = clamp(windYesMax + 12, 0, 80);
    const windBadMin = windMehMax;

    // Temp bands:
    const { comfortMin, comfortMax, coldMin } = tempBandFromPrefs();


    return {
      rainYesMax, rainMehMax, rainBadMin,
      windYesMax, windMehMax, windBadMin,
      comfortMin, comfortMax, coldMin,
    };
  }

  function renderPrefLabels(){
    // Temp preference display (store prefs in Â°C internally, display Â°F if toggled)
    if (tempPrefVal){
      const tMin = state.prefs.tempMin;
      const tMax = state.prefs.tempMax;

      if (state.tempUnit === "F"){
        const fMin = Math.round(cToF(tMin));
        const fMax = Math.round(cToF(tMax));
        tempPrefVal.textContent = `${fMin}Â°F â€“ ${fMax}Â°F`;
      } else {
        tempPrefVal.textContent = `${tMin}Â°C â€“ ${tMax}Â°C`;
      }
    }

    // Rain is always %
    if (rainPrefVal){
      rainPrefVal.textContent = `â‰¤ ${state.prefs.rainTolerance}%`;
    }

    // Wind preference display (store prefs in km/h internally, display mph if toggled)
    if (windPrefVal){
      const w = state.prefs.windTolerance;

      if (state.tempUnit === "F"){
        const mph = Math.round(kmhToMph(w));
        windPrefVal.textContent = `â‰¤ ${mph} mph`;
      } else {
        windPrefVal.textContent = `â‰¤ ${w} km/h`;
      }
    }
  }



  function savePrefs(){
    localStorage.setItem("sigo_prefs", JSON.stringify(state.prefs));
  }

  function loadPrefsFromStorage(){
    try{
      const raw = localStorage.getItem("sigo_prefs");
      if (!raw) return;
      const p = JSON.parse(raw);
      if (!p || typeof p !== "object") return;

      if (typeof p.tempMin === "number") state.prefs.tempMin = clamp(p.tempMin, -5, 40);
      if (typeof p.tempMax === "number") state.prefs.tempMax = clamp(p.tempMax, -5, 40);

      if (typeof p.rainTolerance === "number") state.prefs.rainTolerance = clamp(p.rainTolerance, 0, 100);
      if (typeof p.windTolerance === "number") state.prefs.windTolerance = clamp(p.windTolerance, 0, 60);
    }catch(_e){}
  }

  function setSliderPct(sliderEl){
    if (!sliderEl) return;
    const min = Number(sliderEl.min);
    const max = Number(sliderEl.max);
    const val = Number(sliderEl.value);
    const pct = ((val - min) / (max - min)) * 100;
    sliderEl.style.setProperty("--pct", pct + "%");
  }


  function updateTempRangeFill(){
    if (!tempMinPref || !tempMaxPref || !tempRangeFill) return;

    const min = Number(tempMinPref.min);
    const max = Number(tempMinPref.max);

    const a = Number(tempMinPref.value);
    const b = Number(tempMaxPref.value);

    const lo = Math.min(a, b);
    const hi = Math.max(a, b);

    const loPct = ((lo - min) / (max - min)) * 100;
    const hiPct = ((hi - min) / (max - min)) * 100;

    tempRangeFill.style.left = `${loPct}%`;
    tempRangeFill.style.width = `${hiPct - loPct}%`;
  }
  function setTempActiveThumb(which){
    if (!tempMinPref || !tempMaxPref) return;

    if (which === "min"){
      tempMinPref.style.zIndex = "5";
      tempMaxPref.style.zIndex = "4";
      tempMinPref.style.pointerEvents = "auto";
      tempMaxPref.style.pointerEvents = "none";
    } else {
      tempMaxPref.style.zIndex = "5";
      tempMinPref.style.zIndex = "4";
      tempMaxPref.style.pointerEvents = "auto";
      tempMinPref.style.pointerEvents = "none";
    }
  }

  function resetTempThumbPointerEvents(){
    if (!tempMinPref || !tempMaxPref) return;
    tempMinPref.style.pointerEvents = "auto";
    tempMaxPref.style.pointerEvents = "auto";
  }

  function valueFromPointerEvent(e, inputEl){
    const rect = tempDualRange.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const pct = clamp(x / rect.width, 0, 1);

    const min = Number(inputEl.min);
    const max = Number(inputEl.max);
    const step = Number(inputEl.step) || 1;

    const raw = min + pct * (max - min);
    return Math.round(raw / step) * step;
  }


  function bringTempThumbToFront(which){
    if (!tempMinPref || !tempMaxPref) return;

    if (which === "min"){
      tempMinPref.style.zIndex = "4";
      tempMaxPref.style.zIndex = "3";
    } else {
      tempMaxPref.style.zIndex = "4";
      tempMinPref.style.zIndex = "3";
    }
  }



  function syncPrefControls(){
    if (tempMinPref) tempMinPref.value = String(state.prefs.tempMin);
    if (tempMaxPref) tempMaxPref.value = String(state.prefs.tempMax);

    if (rainPref) rainPref.value = String(state.prefs.rainTolerance);
    if (windPref) windPref.value = String(state.prefs.windTolerance);

    // NEW: set filled-track % for single sliders
    setSliderPct(rainPref);
    setSliderPct(windPref);

    renderPrefLabels();
    updateTempRangeFill();
  }



  function onPrefsChanged(){
    renderPrefLabels();
    savePrefs();

    // Re-render decision/score instantly
    if (state.forecast?.daily?.length){
      renderSelectedDay();
    }
  }


  // Decision + score + reasons
  function decisionEngine(day){
    const precip = day.precipProb ?? 0;
    const wind   = day.windMax ?? 0;
    const uv     = day.uvMax ?? 0;
    const tmax   = day.tmax ?? 20;
    // const tmin   = day.tmin ?? 10; // not used (we only judge max temp)


    const th = computeThresholds();

    // Rain based on prefs
    const rainBad = precip >= th.rainBadMin;
    const rainMeh = precip >= th.rainYesMax && precip < th.rainBadMin;

    // Wind based on prefs
    const windBad = wind >= th.windBadMin;
    const windMeh = wind >= th.windYesMax && wind < th.windBadMin;

    // Temperature based on prefs (ONLY uses daily max temp)
      const tempBad =
        (tmax >= (th.comfortMax + 6)) ||       // "too hot"
        (tmax <= (th.comfortMin - 6));         // "too cold"

      const tempMeh = (!tempBad) && (
        (tmax > th.comfortMax) ||
        (tmax < th.comfortMin)
      );




    const uvBad = (!state.isNight) && uv >= 11;
    const uvMeh = (!state.isNight) && uv >= 8 && uv < 11;

    const badCount =
      (rainBad ? 1 : 0) +
      (windBad ? 1 : 0) +
      (tempBad ? 1 : 0) +
      (uvBad ? 1 : 0);

    const mehCount =
      (rainMeh ? 1 : 0) +
      (windMeh ? 1 : 0) +
      (tempMeh ? 1 : 0) +
      (uvMeh ? 1 : 0);

    let decision = "MAYBE";
    if (badCount >= 1) decision = "NO";
    else if (mehCount >= 3) decision = "NO";
    else if (mehCount <= 1) decision = "YES";
    else decision = "MAYBE";
    if (decision === "YES" && precip > 25) decision = "MAYBE";


    let score = 100;

    // Rain: penalties scale once you exceed your "YES max"
    if (precip >= th.rainBadMin) score -= 50;
    else if (precip >= th.rainYesMax) score -= 25;
    else score -= precip * 0.2;

    // Wind: penalties scale once you exceed your "YES max"
    if (wind >= th.windBadMin) score -= 35;
    else if (wind >= th.windYesMax) score -= 18;
    else if (wind > Math.max(10, th.windYesMax - 10)) score -= (wind - Math.max(10, th.windYesMax - 10)) * 0.6;


    if (tmax >= 35) score -= 35;
    else if (tmax >= 31) score -= 15;

    if (tmax <= 12) score -= 28;
    else if (tmax <= 16) score -= 10;

    // NOTE: no penalties from overnight low (tmin)



    if (!state.isNight){
      if (uv >= 11) score -= 30;
      else if (uv >= 8) score -= 15;
      else if (uv >= 6) score -= 6;
    }

    score = clamp(score, 0, 100);

    const reasons = [];
    const add = (s) => reasons.push(s);

    if (rainBad) add(`Rain risk is high (${Math.round(precip)}%).`);
    else if (rainMeh) add(`Some rain chance (${Math.round(precip)}%).`);

    if (windBad) add(`Wind is strong (${fmtWind(wind)}).`);
    else if (windMeh) add(`Breezy winds (${fmtWind(wind)}).`);


    if (tempBad) add(`Max temp looks uncomfortable (High ${fmtTemp(tmax)}).`);
    else if (tempMeh) add(`Max temp is a bit meh (High ${fmtTemp(tmax)}).`);



    if (!state.isNight){
      if (uvBad) add(`UV is extreme (${Math.round(uv)}).`);
      else if (uvMeh) add(`UV is very high (${Math.round(uv)}).`);
    }

    if ((decision === "MAYBE" || decision === "NO") && reasons.length === 0){
      add("A couple of factors are borderline â€” keep a backup plan.");
    }

    return { decision, score, reasons };
  }

  // Best time window limited to 9amâ€“5pm (2-hour windows)
  function bestWindowForDate(dateStr, hourly, tz){
    if (!hourly || !hourly.time || !hourly.time.length) return "â€”";

    const times = hourly.time;
    const temp = hourly.temperature_2m;
    const rainP = hourly.precipitation_probability;
    const wind = hourly.wind_speed_10m;
    const uv = hourly.uv_index;

    let best = null;

    for (let i = 0; i < times.length - 1; i++){
      if (!times[i].startsWith(dateStr)) continue;

      const d0 = new Date(times[i]);
      const h = d0.getHours();

      if (h < 9 || h > 16) continue;

      const avgTemp = (temp[i] + temp[i+1]) / 2;
      const avgRain = (rainP[i] + rainP[i+1]) / 2;
      const avgWind = (wind[i] + wind[i+1]) / 2;
      const avgUv = (uv[i] + uv[i+1]) / 2;

      let s = 100;
      s -= avgRain * 1.1;
      if (avgWind > 12) s -= (avgWind - 12) * 3.0;
      if (avgUv > 8) s -= (avgUv - 8) * 10.0;

      if (avgTemp < 16) s -= (16 - avgTemp) * 4.0;
      if (avgTemp > 30) s -= (avgTemp - 30) * 6.0;

      if (!best || s > best.score){
        best = { score: s, start: d0, end: new Date(times[i+1]) };
      }
    }

    if (!best) return "â€”";
    const fmt = (d) => d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit", timeZone: tz || undefined });
    return `${fmt(best.start)} â€“ ${fmt(best.end)}`;
  }

  function computeBestWindowsForWeek(dailyArr, hourly, tz){
    const map = new Map();
    for (const d of dailyArr){
      map.set(d.date, bestWindowForDate(d.date, hourly, tz));
    }
    return map;
  }

  function clothingByGender(day){
    const rain = day.precipProb ?? 0;
    const tmax = day.tmax ?? 20;
    const tmin = day.tmin ?? 10;
    const uv = day.uvMax ?? 0;
    const wind = day.windMax ?? 0;

    const male = new Set();
    const female = new Set();

    // Shorts option for anything over 25Â°C âœ…
    if (tmax <= 14){
      male.add("hoodie", "jeans", "closed shoes");
      female.add("sweater", "leggings or jeans", "closed shoes");
    } else if (tmax > 25){
      male.add("t-shirt", "shorts", "breathable shoes");
      female.add("light top", "shorts or dress", "sandals / breathable shoes");
    } else {
      male.add("t-shirt", "jeans or chinos");
      female.add("top", "jeans / skirt");
    }

    if (tmin <= 6 && tmax > 14){
      male.add("light jacket (morning/evening)");
      female.add("light jacket (morning/evening)");
    }
    if (rain >= 35){
      male.add("umbrella");
      female.add("umbrella");
    }
    if (wind >= 30){
      male.add("windbreaker");
      female.add("light jacket");
    }
    if (uv >= 6 && !state.isNight){
      male.add("sunscreen", "hat");
      female.add("sunscreen", "hat");
    }

    if (rain >= 35){
      male.add("closed shoes (avoid soggy socks)");
      female.add("closed shoes (avoid soggy socks)");
    } else if (tmax >= 30){
      male.add("breathable shoes");
      female.add("sandals / breathable shoes");
    }

    return {
      male: Array.from(male).join(", "),
      female: Array.from(female).join(", "),
    };
  }


  function activityIdeas(day, decision){
    const rain = day.precipProb ?? 0;
    const wind = day.windMax ?? 0;
    const uv = day.uvMax ?? 0;
    const tmax = day.tmax ?? 20;

    const outsideNice = [
      "Go for a walk and pretend you're in a motivational ad",
      "Coffee run + people-watch like a professional",
      "Park visit + playlist + main-character energy",
      "Quick errands sprint (speedrun: adulting)",
      "Bike ride / gentle jog (become a legend, briefly)"
    ];

    const outsideMeh = [
      "Short walk (10â€“15 mins) then retreat like a tactical genius",
      "Sit outside under cover and feel superior to indoor people",
      "Go out for one task only (in-and-out operation)",
      "Do a sunset stroll (if the sky behaves)"
    ];

    const outsideBad = [
      "Stand outside for 30 seconds, say â€˜nopeâ€™, go back inside",
      "Only go outside if required by law or snack needs",
      "Umbrella duel with the wind (you will lose)",
      "Take the bins out and call it cardio"
    ];

    const insideNice = [
      "Tidy one small area and take credit for the whole house",
      "Stretch / light workout and feel instantly productive",
      "Plan something fun for later (future-you will clap)",
      "Cook something simple and pretend itâ€™s a lifestyle"
    ];

    const insideBad = [
      "Movie + blanket + no guilt (weather-approved)",
      "Make something warm and call it self-care (it is)",
      "Read / game / nap â€” rotate until morale improves",
      "Do absolutely nothing (elite move)"
    ];

    let outside = [];
    let inside = [];

    if (decision === "YES"){
      outside = outsideNice;
      inside = insideNice;
    } else if (decision === "NO"){
      outside = outsideBad;
      inside = insideBad;
    } else {
      outside = outsideMeh;
      inside = (rain >= 50 || wind >= 35 || tmax >= 33) ? insideBad : insideNice;
    }

    if (uv >= 9 && !state.isNight) outside = outside.map(x => x + " (wear SPF)");
    if (tmax >= 33) outside = outside.map(x => x + " (bring water)");
    if (rain >= 50) outside = outside.map(x => x + " (umbrella required)");
    if (wind >= 35) outside = outside.map(x => x + " (hold your hat)");

    return { outside: outside.slice(0, 3), inside: inside.slice(0, 3) };
  }

  function dailyMotivation(day){
    const rain = day.precipProb ?? 0;
    const tmax = day.tmax ?? 20;
    const wind = day.windMax ?? 0;
    const uv = day.uvMax ?? 0;

    const sunny = [
      "You didnâ€™t come this far to stay inside. Go romanticise your life.",
      "This weather is carrying you. Donâ€™t waste it.",
      "Main-character energy unlocked. Use it responsibly-ish.",
      "Go outside. Collect your free serotonin."
    ];

    const rainy = [
      "Soft days still count. Cozy progress is still progress.",
      "Rest is productive. The rain said so.",
      "The sky is crying so you donâ€™t have to. Take the win.",
      "If itâ€™s wet outside, be warm inside. Thatâ€™s balance."
    ];

    const hot = [
      "Hydrate, survive, conquer. In that order.",
      "Today is spicy. Be smarter than the sun.",
      "Youâ€™re stronger than the heat. Probably.",
      "Move like a lizard: short bursts, then shade."
    ];

    const chaotic = [
      "The weather chose violence. You chose peace.",
      "Not every day is for winning. Some are for surviving politely.",
      "If outside is a scam, youâ€™re allowed to unsubscribe.",
      "You donâ€™t have to prove anything to the wind."
    ];

    if (rain >= 50) return pickByDay(rainy, day.date);
    if (tmax >= 33) return pickByDay(hot, day.date);
    if (wind >= 35 || (uv >= 9 && !state.isNight)) return pickByDay(chaotic, day.date);
    return pickByDay(sunny, day.date);
  }

  function renderGuideExtras(day, decision){
    const clothes = clothingByGender(day);
    maleOutfitText.textContent = clothes.male;
    femaleOutfitText.textContent = clothes.female;


    const acts = activityIdeas(day, decision);
    outsideIdeasText.innerHTML =
      "<ul style='margin:8px 0 0; padding-left:18px; color: var(--muted);'>" +
      acts.outside.map(x => `<li>${escapeHtml(x)}</li>`).join("") +
      "</ul>";

    insideIdeasText.innerHTML =
      "<ul style='margin:8px 0 0; padding-left:18px; color: var(--muted);'>" +
      acts.inside.map(x => `<li>${escapeHtml(x)}</li>`).join("") +
      "</ul>";

    motivationText.textContent = dailyMotivation(day);
  }

  function applyTheme(){
    document.body.setAttribute("data-theme", state.themeMode);
  }


  function cycleTheme(){
    state.themeMode = (state.themeMode === "dark") ? "light" : "dark";

    themeBtn.textContent =
      state.themeMode === "dark"
        ? "ğŸŒ™ Theme: Dark"
        : "â˜€ï¸ Theme: Light";

    localStorage.setItem("sigo_themeMode", state.themeMode);
    applyTheme();
  }


  function setTab(which){
    const isDash = which === "dashboard";

    tabDashboard.classList.toggle("active", isDash);
    tabDashboard.setAttribute("aria-selected", String(isDash));

    tabAbout.classList.toggle("active", !isDash);
    tabAbout.setAttribute("aria-selected", String(!isDash));

    pageDashboard.classList.toggle("hidden", !isDash);
    pageAbout.classList.toggle("hidden", isDash);

    const searchRow = document.getElementById("searchRow");
    if (searchRow) searchRow.classList.toggle("hidden", !isDash);

    const toggleRow = document.getElementById("toggleRow");
    if (toggleRow) toggleRow.classList.remove("hidden");

    if (isDash) placeInput?.focus();
  }

  // Suggestions UI
  function openSuggestions(){
    state.suggestionOpen = true;
    suggestionsEl.classList.add("show");
  }
  function closeSuggestions(){
    state.suggestionOpen = false;
    state.suggestionActiveIndex = -1;
    suggestionsEl.classList.remove("show");
    suggestionsEl.innerHTML = "";
    state.suggestionItems = [];
  }
  function renderSuggestions(items){
    state.suggestionItems = items || [];
    state.suggestionActiveIndex = -1;

    if (!items || items.length === 0){
      closeSuggestions();
      return;
    }

    suggestionsEl.innerHTML = items.map((it, idx) => {
      const title = `${it.name}${it.admin1 ? ", " + it.admin1 : ""}`;
      const sub = `${it.country}${it.latitude != null ? " â€¢ " + it.latitude.toFixed(3) + "," + it.longitude.toFixed(3) : ""}`;
      return `
        <div class="sItem" role="option" data-idx="${idx}">
          <div class="sPin">ğŸ“</div>
          <div>
            <div class="sTitle">${escapeHtml(title)}</div>
            <div class="sSub">${escapeHtml(sub)}</div>
          </div>
        </div>
      `;
    }).join("");

    openSuggestions();

    suggestionsEl.querySelectorAll(".sItem").forEach(el => {
      el.addEventListener("mousedown", (e) => e.preventDefault());
      el.addEventListener("click", () => {
        const idx = Number(el.getAttribute("data-idx"));
        chooseSuggestion(idx);
      });
    });
  }

  function highlightSuggestion(){
    const nodes = Array.from(suggestionsEl.querySelectorAll(".sItem"));
    nodes.forEach((n, i) => n.classList.toggle("active", i === state.suggestionActiveIndex));
  }

  function chooseSuggestion(idx){
    const it = state.suggestionItems[idx];
    if (!it) return;

    const display = `${it.name}${it.admin1 ? ", " + it.admin1 : ""}${it.country ? ", " + it.country : ""}`;
    placeInput.value = display;

    state.name = `${it.name}${it.admin1 ? ", " + it.admin1 : ""}`;
    state.country = it.country || "";
    state.lat = it.latitude;
    state.lon = it.longitude;
    state.timezone = it.timezone || "auto";

    localStorage.setItem("sigo_last_place", JSON.stringify({
      name: state.name,
      country: state.country,
      lat: state.lat,
      lon: state.lon,
      timezone: state.timezone,
      display
    }));

    closeSuggestions();
    fetchForecastAndRender();
  }

  // Network helpers
  async function safeJson(url){
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }

  async function geocodeSearch(query){
    const url =
      `${GEO_URL}?name=${encodeURIComponent(query)}&count=7&language=en&format=json`;
    const data = await safeJson(url);
    const items = (data && data.results) ? data.results : [];
    return items;
  }

  async function reverseGeocode(lat, lon){
    const url =
      `${GEO_REV_URL}?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}&count=10&language=en&format=json`;
    const data = await safeJson(url);
    const items = (data && data.results) ? data.results : [];
    return items[0] || null;
  }

  function nicePlaceName(p){
    const parts = [];
    if (p?.name) parts.push(p.name);
    if (p?.admin1) parts.push(p.admin1);
    return parts.join(", ").trim();
  }

  async function resolveNearestTown(lat, lon){
    // 1) Reverse geocode (best)
    try{
      const place = await reverseGeocode(lat, lon);
      if (place?.name) return place;
    }catch(_e){}

    // 2) Fallback: try searching the coords as text (sometimes returns nearby locality)
    try{
      const q = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
      const items = await geocodeSearch(q);
      if (items && items.length){
        let best = items[0];
        let bestD = Infinity;

        for (const it of items){
          if (it.latitude == null || it.longitude == null) continue;
          const dLat = (it.latitude - lat);
          const dLon = (it.longitude - lon);
          const d = dLat*dLat + dLon*dLon;
          if (d < bestD){
            bestD = d;
            best = it;
          }
        }
        return best;
      }
    }catch(_e){}

    // 3) Give up gracefully
    return null;
  }

  async function reverseGeocodeBDC(lat, lon){
    const url =
      `${BDC_REV_URL}?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}&localityLanguage=en`;

    const data = await safeJson(url);

    // BigDataCloud fields (common):
    // data.locality, data.city, data.principalSubdivision, data.countryName
    const name = (data.locality || data.city || data.localityInfo?.administrative?.[0]?.name || "").trim();
    const admin1 = (data.principalSubdivision || "").trim();
    const country = (data.countryName || "").trim();

    if (!name && !admin1 && !country) return null;

    // Return in a shape similar to Open-Meteo results so the rest of your code works
    return {
      name: name || admin1 || "Unknown area",
      admin1: admin1 || "",
      country: country || "",
      latitude: lat,
      longitude: lon,
      timezone: "auto",
    };
  }


  
  function buildForecastUrl(){
    const dailyFields = [
      "temperature_2m_max",
      "temperature_2m_min",
      "precipitation_probability_max",
      "wind_speed_10m_max",
      "relative_humidity_2m_max",
      "uv_index_max",
    ].join(",");

    const hourlyFields = [
      "temperature_2m",
      "precipitation_probability",
      "wind_speed_10m",
      "uv_index",
      "relative_humidity_2m",
    ].join(",");

    const params = new URLSearchParams({
      latitude: String(state.lat),
      longitude: String(state.lon),

      // Always request 7 days
      forecast_days: "7",

      // fields
      daily: dailyFields,
      hourly: hourlyFields,

      // IMPORTANT: let Open-Meteo decide tz for the lat/lon and return it
      timezone: "auto",

      // nice extras
      wind_speed_unit: "kmh",
      temperature_unit: "celsius",
    });

    return `${FORECAST_URL}?${params.toString()}`;
  }

  function normalizeForecast(raw){
    const d = raw?.daily || {};
    const days = (d.time || []).map((dateStr, i) => ({
      date: dateStr,
      tmax: d.temperature_2m_max?.[i],
      tmin: d.temperature_2m_min?.[i],
      precipProb: d.precipitation_probability_max?.[i],
      windMax: d.wind_speed_10m_max?.[i],
      humidityMax: d.relative_humidity_2m_max?.[i],
      uvMax: d.uv_index_max?.[i],
    }));

    return {
      timezone: raw?.timezone || "auto",
      daily: days,
      hourly: raw?.hourly || null,
    };
  }

  function getCurrentFromHourly(hourly, tz){
    if (!hourly?.time?.length) return null;

    const times = hourly.time;

    // "now" in the forecast timezone (so it doesn't drift)
    const now = new Date();
    const nowISO = new Date(now.toLocaleString("en-US", { timeZone: tz || undefined }));

    // find nearest hour index
    let bestIdx = 0;
    let bestDiff = Infinity;

    for (let i = 0; i < times.length; i++){
      const t = new Date(times[i]);
      const diff = Math.abs(t.getTime() - nowISO.getTime());
      if (diff < bestDiff){
        bestDiff = diff;
        bestIdx = i;
      }
    }

    return {
      temp: hourly.temperature_2m?.[bestIdx] ?? null,
      wind: hourly.wind_speed_10m?.[bestIdx] ?? null,
      rain: hourly.precipitation_probability?.[bestIdx] ?? null,
      humidity: hourly.relative_humidity_2m?.[bestIdx] ?? null,
      uv: hourly.uv_index?.[bestIdx] ?? null,
    };
  }


  function setAnswer(decision){
    answerText.textContent = decision;
    answerText.classList.remove("yes","no","maybe");
    if (decision === "YES") answerText.classList.add("yes");
    else if (decision === "NO") answerText.classList.add("no");
    else answerText.classList.add("maybe");
  }

  function renderDays(){
    const tz = state.timezone && state.timezone !== "auto" ? state.timezone : undefined;
    const daily = state.forecast?.daily || [];

    daysRow.innerHTML = daily.map((d, idx) => {
      const emoji = dominantWeatherEmoji(d);
      const active = idx === state.selectedIndex ? "active" : "";
      const rain = d.precipProb == null ? "â€”" : `${Math.round(d.precipProb)}%`;
      const hi = fmtTemp(d.tmax);
      const isToday = idx === 0;
      
      
      return `
        <div class="dayCard ${active}" data-idx="${idx}" role="button" tabindex="0" aria-label="Select ${escapeHtml(d.date)}">
          <div class="dayTop">
            <div>
              <div class="dow">${escapeHtml(fmtDay(d.date, tz))}</div>
              <div class="mini"><span>${escapeHtml(fmtShort(d.date, tz))}</span></div>
            </div>
            <div class="emoji" aria-hidden="true">${emoji}</div>
          </div>
          <div class="mini"><span>ğŸŒ¡ï¸</span><strong>${hi}</strong></div>
          <div class="mini"><span>â˜”</span><strong>${rain}</strong></div>

        </div>
      `;
    }).join("");

    daysRow.querySelectorAll(".dayCard").forEach(card => {
      const pick = () => {
        const idx = Number(card.getAttribute("data-idx"));
        if (!Number.isFinite(idx)) return;
        state.selectedIndex = idx;
        renderSelectedDay();
      };
      card.addEventListener("click", pick);
      card.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") { e.preventDefault(); pick(); }
      });
    });
  }

  function renderSelectedDay(){
    const f = state.forecast;
    if (!f?.daily?.length) return;

    // keep selection safe
    state.selectedIndex = clamp(state.selectedIndex, 0, f.daily.length - 1);

    const day = f.daily[state.selectedIndex];
    const tz = state.timezone && state.timezone !== "auto" ? state.timezone : undefined;
    // âœ… Current conditions: only show when selected day is Today (index 0)
    if (state.selectedIndex === 0 && state.current){
      const t = state.current.temp != null ? fmtTemp(state.current.temp) : "â€”";
      const w = state.current.wind != null ? fmtWind(state.current.wind) : "â€”";
      const r = state.current.rain != null ? `${Math.round(state.current.rain)}%` : "â€”";
      const u = (state.current.uv != null && !state.isNight) ? `${Math.round(state.current.uv)}` : "â€”";

      currentVal.textContent = `Temp ${t} â€¢ Wind ${w} â€¢ Rain ${r} â€¢ UV ${u}`;
      currentMetric.style.display = "";
    } else {
      currentMetric.style.display = "none";
    }
    selectedChip.textContent = `Selected: ${state.selectedIndex === 0 ? "Today" : fmtShort(day.date, tz)}`;

    // decision
    computeNightFlag();
    applyTheme();

    const { decision, score, reasons } = decisionEngine(day);
    setAnswer(decision);

    // stable per-day quip (doesn't change on refresh)
    const quip = state.quipsByDate.get(day.date) || pickByDay(QUIPS.normal.meh, day.date);
    quipText.textContent = quip;

    // reasons
    reasonText.innerHTML = reasons.length ? escapeHtml(reasons.join(" ")) : "&nbsp;";


    // metrics
    humidityVal.textContent = (day.humidityMax == null) ? "â€”" : `${Math.round(day.humidityMax)}%`;
    windVal.textContent = (day.windMax == null) ? "â€”" : fmtWind(day.windMax);
    rainVal.textContent = (day.precipProb == null) ? "â€”" : `${Math.round(day.precipProb)}%`;
    tempVal.textContent = (day.tmax == null || day.tmin == null)
      ? "â€”"
      : `${fmtTemp(day.tmax)} / ${fmtTemp(day.tmin)}`;

    uvVal.textContent = (day.uvMax == null) ? "â€”" : `${uvLabel(day.uvMax)} (${Math.round(day.uvMax)})`;

    // best window (precomputed per day)
    const best = state.bestWindowByDate.get(day.date) || "â€”";
    bestTimeVal.textContent = best;

    // little extra summary on the right
    extraSummary.textContent = `Score: ${Math.round(score)}/100`;

    // â€œmoney noteâ€ vibe
    if (decision === "YES") {
      moneyNote.textContent = "ğŸŒ¿ Yes: go outside and pretend youâ€™re a healthy person. (Scientific vibes, not science.)";
    } else if (decision === "NO") {
      moneyNote.textContent = "ğŸ›‹ï¸ No: indoors is a valid lifestyle choice today. (Scientific vibes, not science.)";
    } else {
      moneyNote.textContent = "ğŸ¤ Maybe: do a short mission outside, then retreat like a tactical genius.";
    }

    // guide (clothing includes shorts > 25Â°C âœ…)
    renderGuideExtras(day, decision);

    // re-render active day highlight
    renderDays();
  }

  function updateMetaChips(){
    const tz = state.timezone && state.timezone !== "auto" ? state.timezone : undefined;

    // IMPORTANT: show a stable â€œnowâ€ with timezone when possible
    const now = new Date();
    const timeStr = now.toLocaleString(undefined, {
      weekday: "short",
      hour: "2-digit",
      minute: "2-digit",
      timeZone: tz,
    });

    timeChip.textContent = `â±ï¸ ${timeStr}`;
    locationChip.textContent = `ğŸ“ ${state.name}${state.country ? ", " + state.country : ""}`;
  }

  async function fetchForecastAndRender(){
    if (state.lat == null || state.lon == null) return;

    quipText.textContent = "Fetching forecastâ€¦";
    reasonText.textContent = "";
    locationChip.textContent = `ğŸ“ ${state.name || "Loadingâ€¦"}`;

    try{
      const url = buildForecastUrl();
      const raw = await safeJson(url);
      state.forecast = normalizeForecast(raw);

      // lock timezone to forecast timezone so day labels donâ€™t â€œshiftâ€
      if (state.forecast.timezone) state.timezone = state.forecast.timezone;
      state.current = getCurrentFromHourly(state.forecast.hourly, state.timezone);


      // build stable quips + best windows for the entire week
      state.quipsByDate = buildUniqueQuipsForWeek(state.forecast.daily);
      state.bestWindowByDate = computeBestWindowsForWeek(state.forecast.daily, state.forecast.hourly, state.timezone);

      updateMetaChips();
      applyTheme();
      renderDays();
      renderSelectedDay();
    }catch(err){
      setAnswer("MAYBE");
      quipText.textContent = "Couldnâ€™t load weather. The internet is having feelings.";
      reasonText.textContent = "Try again, or search a nearby town/suburb.";
      console.error(err);
    }
  }

  // ---------------------------
  // Location: â€œUse my locationâ€
  // ---------------------------
  async function useMyLocationGPS(){
    if (!("geolocation" in navigator)){
      alert("Geolocation not supported in this browser.");
      return;
    }

    useMeBtn.disabled = true;
    useMeBtn.classList.add("loading");

    try{
      const pos = await new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
          timeout: 12000,
          maximumAge: 30000,
        });
      });

      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;

      // Always set coords first so forecast works even if name lookup fails
      state.lat = lat;
      state.lon = lon;
      state.timezone = "auto";

      // Temporary UI while we try to get a name
      const fallbackName = `${lat.toFixed(3)}, ${lon.toFixed(3)}`;
      state.name = fallbackName;
      state.country = "";

      // âœ… Resolve nearest town/suburb for these GPS coords (with fallback)
      try{
        // 1) Try Open-Meteo reverse first
        let place = await resolveNearestTown(lat, lon);

        // 2) If that fails, try BigDataCloud
        if (!place?.name){
          place = await reverseGeocodeBDC(lat, lon);
        }

        if (place?.name){
          state.name = nicePlaceName(place) || place.name;
          state.country = place.country || "";
          state.timezone = place.timezone || "auto";
        } else {
          // Keep GPS fallback
          state.name = fallbackName;
          state.country = "";
          state.timezone = "auto";
        }
      } catch (_err){
        // Keep GPS fallback
        state.name = fallbackName;
        state.country = "";
        state.timezone = "auto";
      }



      // Update input + persist
      const display =
      state.country
        ? `${state.name}, ${state.country}`
        : (state.name.includes(",") ? `Near ${state.name}` : `GPS: ${state.name}`);


      placeInput.value = display;

      localStorage.setItem("sigo_last_place", JSON.stringify({
        name: state.name,
        country: state.country,
        lat: state.lat,
        lon: state.lon,
        timezone: state.timezone,
        display
      }));

      // Now fetch weather using coords no matter what
      await fetchForecastAndRender();

    } catch (err){
      // Common geolocation errors:
      // 1 = permission denied, 2 = position unavailable, 3 = timeout
      const code = err?.code;
      const msg =
        code === 1 ? "Location permission denied."
        : code === 2 ? "Position unavailable."
        : code === 3 ? "Location request timed out."
        : "Could not get your location.";

      alert(msg);
    } finally{
      useMeBtn.disabled = false;
      useMeBtn.classList.remove("loading");
    }
  }
  


  // ---------------------------
  // Search suggestions
  // ---------------------------
  let searchTimer = null;

  async function runSuggest(){
    const q = placeInput.value.trim();
    if (q.length < 2){
      closeSuggestions();
      return;
    }
    try{
      const items = await geocodeSearch(q);
      renderSuggestions(items);
    }catch(e){
      console.error(e);
      closeSuggestions();
    }
  }

  function commitEnterSearch(){
    // If user has a highlighted suggestion -> choose it
    if (state.suggestionOpen && state.suggestionActiveIndex >= 0){
      chooseSuggestion(state.suggestionActiveIndex);
      return;
    }

    // Otherwise: geocode the typed query and pick first result
    const q = placeInput.value.trim();
    if (!q) return;

    (async () => {
      try{
        const items = await geocodeSearch(q);
        if (items && items.length){
          renderSuggestions(items);
          chooseSuggestion(0);
        } else {
          alert("No results. Try a bigger place name (e.g., 'Sunbury, Victoria').");
        }
      }catch(e){
        console.error(e);
        alert("Search failed. Check your connection and try again.");
      }
    })();
  }

  function onInputKeyDown(e){
    if (!state.suggestionOpen){
      if (e.key === "Enter") commitEnterSearch();
      return;
    }

    const max = state.suggestionItems.length - 1;

    if (e.key === "ArrowDown"){
      e.preventDefault();
      state.suggestionActiveIndex = clamp(state.suggestionActiveIndex + 1, 0, max);
      highlightSuggestion();
      return;
    }
    if (e.key === "ArrowUp"){
      e.preventDefault();
      state.suggestionActiveIndex = clamp(state.suggestionActiveIndex - 1, -1, max);
      highlightSuggestion();
      return;
    }
    if (e.key === "Escape"){
      closeSuggestions();
      return;
    }
    if (e.key === "Enter"){
      e.preventDefault();
      commitEnterSearch();
      return;
    }
  }

  function toggleTempUnit(){
    state.tempUnit = (state.tempUnit === "C") ? "F" : "C";
    localStorage.setItem("sigo_tempUnit", state.tempUnit);
    setUnitButtonLabel();

    // âœ… Update the preference pills (temp range + wind tolerance)
    renderPrefLabels();

    // Re-render everything that shows temps
    if (state.forecast?.daily?.length){
      renderSelectedDay();
    }
  }



  // ---------------------------
  // Sass + theme
  // ---------------------------
  function toggleSass(){
    state.extraSass = !state.extraSass;
    sassBtn.textContent = state.extraSass ? "âœ¨ Extra Sass: On" : "âœ¨ Extra Sass: Off";
    localStorage.setItem("sigo_extraSass", state.extraSass ? "1" : "0");

    // rebuild quips for current week so it updates immediately but stays stable
    if (state.forecast?.daily?.length){
      state.quipsByDate = buildUniqueQuipsForWeek(state.forecast.daily);
      renderSelectedDay();
    }
  }

  // ---------------------------
  // Init
  // ---------------------------
  function loadPrefs(){
    state.extraSass = localStorage.getItem("sigo_extraSass") === "1";
    sassBtn.textContent = state.extraSass ? "âœ¨ Extra Sass: On" : "âœ¨ Extra Sass: Off";

    state.themeMode = localStorage.getItem("sigo_themeMode") || "dark";

    themeBtn.textContent =
      state.themeMode === "dark"
        ? "ğŸŒ™ Theme: Dark"
        : "â˜€ï¸ Theme: Light";


      state.tempUnit = localStorage.getItem("sigo_tempUnit") || "C";
      setUnitButtonLabel();
    
      loadPrefsFromStorage();
      syncPrefControls();

  }

  function loadLastPlace(){
    const raw = localStorage.getItem("sigo_last_place");
    if (!raw) return false;
    try{
      const p = JSON.parse(raw);
      if (p && typeof p.lat === "number" && typeof p.lon === "number"){
        state.name = p.name || "Saved place";
        state.country = p.country || "";
        state.lat = p.lat;
        state.lon = p.lon;
        state.timezone = p.timezone || "auto";
        placeInput.value = p.display || `${state.name}${state.country ? ", " + state.country : ""}`;
        return true;
      }
    }catch(_){}
    return false;
  }

  // ---------------------------
  // Wire up UI events
  // ---------------------------
  tabDashboard.addEventListener("click", () => setTab("dashboard"));
  tabAbout.addEventListener("click", () => setTab("about"));

  sassBtn.addEventListener("click", toggleSass);
  themeBtn.addEventListener("click", cycleTheme);
  unitBtn?.addEventListener("click", toggleTempUnit);


  useMeBtn.addEventListener("click", () => {
      useMyLocationGPS();
    });

  placeInput.addEventListener("input", () => {
    clearTimeout(searchTimer);
    searchTimer = setTimeout(runSuggest, 220);
  });


  rainPref?.addEventListener("input", () => {
    state.prefs.rainTolerance = Number(rainPref.value);
    setSliderPct(rainPref); // NEW
    onPrefsChanged();
  });

  windPref?.addEventListener("input", () => {
    state.prefs.windTolerance = Number(windPref.value);
    setSliderPct(windPref); // NEW
    onPrefsChanged();
  });




 // âœ… Dual temp range drag handling (wrapper is the only interactive thing)
  let activeTempThumb = null;      // "min" | "max"
  let lastTempThumb = "max";       // âœ… remember last selected thumb
  let draggingTemp = false;

  function setTempFromEvent(e){
    if (!tempMinPref || !tempMaxPref || !tempDualRange) return;

    const val = valueFromPointerEvent(e, tempMinPref);

    if (activeTempThumb === "min"){
      const clamped = Math.min(val, Number(tempMaxPref.value));
      tempMinPref.value = String(clamped);
      tempMinPref.dispatchEvent(new Event("input", { bubbles: true }));
    } else {
      const clamped = Math.max(val, Number(tempMinPref.value));
      tempMaxPref.value = String(clamped);
      tempMaxPref.dispatchEvent(new Event("input", { bubbles: true }));
    }
  }

  tempDualRange?.addEventListener("pointerdown", (e) => {
    if (!tempMinPref || !tempMaxPref) return;

    e.preventDefault();
    tempDualRange.setPointerCapture?.(e.pointerId);

    const clickVal = valueFromPointerEvent(e, tempMinPref);
    const minVal = Number(tempMinPref.value);
    const maxVal = Number(tempMaxPref.value);

    const distToMin = Math.abs(clickVal - minVal);
    const distToMax = Math.abs(clickVal - maxVal);

    // âœ… If overlapping OR equal distance, move the last-used thumb
    const overlapped = (minVal === maxVal);
    const tie = (distToMin === distToMax);

    if (overlapped || tie){
      activeTempThumb = lastTempThumb;
    } else {
      activeTempThumb = (distToMin < distToMax) ? "min" : "max";
    }

    // remember for next time
    lastTempThumb = activeTempThumb;

    draggingTemp = true;
    setTempFromEvent(e);
  });

  tempDualRange?.addEventListener("pointermove", (e) => {
    if (!draggingTemp) return;
    e.preventDefault();
    setTempFromEvent(e);
  });

  tempDualRange?.addEventListener("pointerup", (e) => {
    draggingTemp = false;
    activeTempThumb = null;
    tempDualRange.releasePointerCapture?.(e.pointerId);
  });

  tempDualRange?.addEventListener("pointercancel", (e) => {
    draggingTemp = false;
    activeTempThumb = null;
    tempDualRange.releasePointerCapture?.(e.pointerId);
  });



  
  // Keep your existing logic on input
  tempMinPref?.addEventListener("input", () => {
    state.prefs.tempMin = Number(tempMinPref.value);

    if (state.prefs.tempMin > state.prefs.tempMax){
      state.prefs.tempMax = state.prefs.tempMin;
      tempMaxPref.value = String(state.prefs.tempMax);
    }

    updateTempRangeFill();
    onPrefsChanged();
  });

  tempMaxPref?.addEventListener("input", () => {
    state.prefs.tempMax = Number(tempMaxPref.value);

    if (state.prefs.tempMax < state.prefs.tempMin){
      state.prefs.tempMin = state.prefs.tempMax;
      tempMinPref.value = String(state.prefs.tempMin);
    }

    updateTempRangeFill();
    onPrefsChanged();
  });







  placeInput.addEventListener("keydown", onInputKeyDown);

  document.addEventListener("click", (e) => {
    // click outside suggestions -> close
    if (!suggestionsEl.contains(e.target) && e.target !== placeInput){
      closeSuggestions();
    }
  });

  // keep time chip updated without changing â€œday selectionâ€
  setInterval(() => {
    if (state.lat != null) updateMetaChips();
  }, 30_000);

  // Start
  computeNightFlag();
  loadPrefs();
  applyTheme();

  const hadLast = loadLastPlace();
  if (hadLast){
    updateMetaChips();
    fetchForecastAndRender();
  } else {
    // No saved place: donâ€™t auto-prompt geolocation; show hint.
    locationChip.textContent = state.country
      ? `ğŸ“ ${state.name}, ${state.country}`
      : `ğŸ“ GPS: ${state.name}`;

    timeChip.textContent = "â±ï¸ â€”";
    quipText.textContent = "Search a suburb/city to beginâ€¦";
  }
})();
</script>

</body>
</html>
